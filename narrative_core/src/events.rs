//! Game events for core<->rules communication.
//!
//! Events flow from the game engine INTO the narrative core.
//! The core responds with narrative text and may trigger follow-up events.

use game_rules::{EntityId, LocationId, QuestId, Season, WorldTime};
use serde::{Deserialize, Serialize};

use crate::knowledge_base::{FactId, Tag};

/// All possible game events that the narrative core can process.
///
/// Events are the primary means of communication from the game engine
/// to the narrative core. Each event type carries specific data relevant
/// to the narrative generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GameEvent {
    // ==================== Combat Events ====================
    /// An ability was used in combat.
    CombatAbilityUsed {
        source: EntityId,
        target: EntityId,
        ability: String,
    },

    /// Combat has started.
    CombatStarted {
        participants: Vec<EntityId>,
        location: LocationId,
    },

    /// Combat has ended.
    CombatEnded {
        victor: Option<EntityId>,
        participants: Vec<EntityId>,
    },

    /// An entity took damage.
    EntityDamaged {
        entity: EntityId,
        damage: i32,
        source: Option<EntityId>,
    },

    /// An entity died.
    EntityDied {
        entity: EntityId,
        killer: Option<EntityId>,
    },

    // ==================== Dialogue Events ====================
    /// Dialogue has started.
    DialogueStarted {
        participants: Vec<EntityId>,
        topic: Option<String>,
    },

    /// A dialogue choice was made.
    DialogueChoice {
        speaker: EntityId,
        choice: String,
        listeners: Vec<EntityId>,
    },

    /// Dialogue has ended.
    DialogueEnded { participants: Vec<EntityId> },

    // ==================== World Events ====================
    /// An entity entered a location.
    LocationEntered {
        entity: EntityId,
        location: LocationId,
    },

    /// An entity exited a location.
    LocationExited {
        entity: EntityId,
        location: LocationId,
    },

    /// An item was picked up.
    ItemPickedUp { entity: EntityId, item: EntityId },

    /// An item was used.
    ItemUsed {
        entity: EntityId,
        item: EntityId,
        target: Option<EntityId>,
    },

    // ==================== Time Events ====================
    /// Time has advanced.
    TimeAdvanced {
        old_time: WorldTime,
        new_time: WorldTime,
    },

    /// A new day has started.
    DayChanged { day: u32 },

    /// Season has changed.
    SeasonChanged { season: Season },

    // ==================== Quest Events ====================
    /// A quest was started.
    QuestStarted {
        quest_id: QuestId,
        initiator: Option<EntityId>,
    },

    /// A quest objective was completed.
    QuestObjectiveCompleted {
        quest_id: QuestId,
        objective_id: String,
    },

    /// A quest was completed.
    QuestCompleted { quest_id: QuestId },

    // ==================== Relationship Events ====================
    /// Relationship between entities changed (generated by narrative core).
    RelationshipModified {
        entity_a: EntityId,
        entity_b: EntityId,
        old_sentiment: f32,
        new_sentiment: f32,
        reason: String,
    },

    /// A secret was revealed.
    SecretRevealed {
        fact_id: FactId,
        revealed_to: Vec<EntityId>,
    },

    // ==================== Custom Events ====================
    /// Custom event for extensibility.
    Custom {
        event_type: String,
        data: serde_json::Value,
    },
}

impl GameEvent {
    /// Get the primary entity involved in this event.
    pub fn primary_entity(&self) -> Option<EntityId> {
        match self {
            GameEvent::CombatAbilityUsed { source, .. } => Some(*source),
            GameEvent::EntityDamaged { entity, .. } => Some(*entity),
            GameEvent::EntityDied { entity, .. } => Some(*entity),
            GameEvent::DialogueStarted { participants, .. } => participants.first().copied(),
            GameEvent::DialogueChoice { speaker, .. } => Some(*speaker),
            GameEvent::LocationEntered { entity, .. } => Some(*entity),
            GameEvent::LocationExited { entity, .. } => Some(*entity),
            GameEvent::ItemPickedUp { entity, .. } => Some(*entity),
            GameEvent::ItemUsed { entity, .. } => Some(*entity),
            GameEvent::QuestStarted { initiator, .. } => *initiator,
            _ => None,
        }
    }

    /// Get all entities involved in this event.
    pub fn involved_entities(&self) -> Vec<EntityId> {
        match self {
            GameEvent::CombatAbilityUsed { source, target, .. } => vec![*source, *target],
            GameEvent::CombatStarted { participants, .. } => participants.clone(),
            GameEvent::CombatEnded { participants, victor, .. } => {
                let mut entities = participants.clone();
                if let Some(v) = victor {
                    if !entities.contains(v) {
                        entities.push(*v);
                    }
                }
                entities
            }
            GameEvent::EntityDamaged { entity, source, .. } => {
                let mut entities = vec![*entity];
                if let Some(s) = source {
                    entities.push(*s);
                }
                entities
            }
            GameEvent::EntityDied { entity, killer, .. } => {
                let mut entities = vec![*entity];
                if let Some(k) = killer {
                    entities.push(*k);
                }
                entities
            }
            GameEvent::DialogueStarted { participants, .. } => participants.clone(),
            GameEvent::DialogueChoice {
                speaker, listeners, ..
            } => {
                let mut entities = vec![*speaker];
                entities.extend(listeners);
                entities
            }
            GameEvent::DialogueEnded { participants } => participants.clone(),
            GameEvent::RelationshipModified {
                entity_a,
                entity_b,
                ..
            } => vec![*entity_a, *entity_b],
            GameEvent::SecretRevealed { revealed_to, .. } => revealed_to.clone(),
            _ => self.primary_entity().into_iter().collect(),
        }
    }

    /// Convert this event to a set of tags for knowledge base lookup.
    pub fn to_tags(&self) -> Vec<Tag> {
        let mut tags = Vec::new();

        // Add entity tags
        for entity in self.involved_entities() {
            tags.push(Tag::entity(entity));
        }

        // Add event-specific tags
        match self {
            GameEvent::CombatAbilityUsed { ability, .. } => {
                tags.push(Tag::concept("Combat"));
                tags.push(Tag::concept(ability.clone()));
                tags.push(Tag::event_type("CombatAbility"));
            }
            GameEvent::CombatStarted { location, .. } => {
                tags.push(Tag::concept("Combat"));
                tags.push(Tag::location(*location));
                tags.push(Tag::event_type("CombatStart"));
            }
            GameEvent::CombatEnded { .. } => {
                tags.push(Tag::concept("Combat"));
                tags.push(Tag::event_type("CombatEnd"));
            }
            GameEvent::EntityDied { .. } => {
                tags.push(Tag::concept("Death"));
                tags.push(Tag::concept("Combat"));
                tags.push(Tag::event_type("Death"));
            }
            GameEvent::DialogueStarted { topic, .. } => {
                tags.push(Tag::concept("Dialogue"));
                if let Some(t) = topic {
                    tags.push(Tag::concept(t.clone()));
                }
                tags.push(Tag::event_type("DialogueStart"));
            }
            GameEvent::DialogueChoice { choice, .. } => {
                tags.push(Tag::concept("Dialogue"));
                tags.push(Tag::event_type("DialogueChoice"));
                // Add the choice as a concept tag for context
                tags.push(Tag::concept(choice.clone()));
            }
            GameEvent::LocationEntered { location, .. } => {
                tags.push(Tag::location(*location));
                tags.push(Tag::event_type("LocationEnter"));
            }
            GameEvent::LocationExited { location, .. } => {
                tags.push(Tag::location(*location));
                tags.push(Tag::event_type("LocationExit"));
            }
            GameEvent::QuestStarted { quest_id, .. } => {
                tags.push(Tag::event_type("QuestStart"));
                tags.push(Tag::custom(format!("quest:{}", quest_id.0)));
            }
            GameEvent::QuestCompleted { quest_id } => {
                tags.push(Tag::event_type("QuestComplete"));
                tags.push(Tag::custom(format!("quest:{}", quest_id.0)));
            }
            GameEvent::RelationshipModified { .. } => {
                tags.push(Tag::concept("Relationship"));
                tags.push(Tag::event_type("RelationshipChange"));
            }
            GameEvent::SecretRevealed { .. } => {
                tags.push(Tag::concept("Secret"));
                tags.push(Tag::concept("Revelation"));
                tags.push(Tag::event_type("SecretReveal"));
            }
            GameEvent::TimeAdvanced { .. } => {
                tags.push(Tag::event_type("TimeAdvance"));
            }
            GameEvent::SeasonChanged { season } => {
                tags.push(Tag::event_type("SeasonChange"));
                tags.push(Tag::concept(format!("{:?}", season)));
            }
            _ => {}
        }

        tags
    }

    /// Get a short type name for this event.
    pub fn event_type_name(&self) -> &'static str {
        match self {
            GameEvent::CombatAbilityUsed { .. } => "CombatAbilityUsed",
            GameEvent::CombatStarted { .. } => "CombatStarted",
            GameEvent::CombatEnded { .. } => "CombatEnded",
            GameEvent::EntityDamaged { .. } => "EntityDamaged",
            GameEvent::EntityDied { .. } => "EntityDied",
            GameEvent::DialogueStarted { .. } => "DialogueStarted",
            GameEvent::DialogueChoice { .. } => "DialogueChoice",
            GameEvent::DialogueEnded { .. } => "DialogueEnded",
            GameEvent::LocationEntered { .. } => "LocationEntered",
            GameEvent::LocationExited { .. } => "LocationExited",
            GameEvent::ItemPickedUp { .. } => "ItemPickedUp",
            GameEvent::ItemUsed { .. } => "ItemUsed",
            GameEvent::TimeAdvanced { .. } => "TimeAdvanced",
            GameEvent::DayChanged { .. } => "DayChanged",
            GameEvent::SeasonChanged { .. } => "SeasonChanged",
            GameEvent::QuestStarted { .. } => "QuestStarted",
            GameEvent::QuestObjectiveCompleted { .. } => "QuestObjectiveCompleted",
            GameEvent::QuestCompleted { .. } => "QuestCompleted",
            GameEvent::RelationshipModified { .. } => "RelationshipModified",
            GameEvent::SecretRevealed { .. } => "SecretRevealed",
            GameEvent::Custom { .. } => "Custom",
        }
    }
}

/// Emotional tone of narrative.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum EmotionalTone {
    Dark,
    Light,
    Tense,
    Romantic,
    Mysterious,
    Neutral,
}

/// The narrative response sent back to game engine.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NarrativeResponse {
    /// Text to display to the player.
    pub narrative_text: String,

    /// Suggested player actions (optional).
    pub suggested_actions: Vec<String>,

    /// Emotional tone for UI/audio hints.
    pub emotional_tone: EmotionalTone,

    /// Events triggered by this narrative.
    pub triggered_events: Vec<GameEvent>,
}

impl NarrativeResponse {
    /// Create a simple narrative response with just text.
    pub fn simple(text: impl Into<String>) -> Self {
        Self {
            narrative_text: text.into(),
            suggested_actions: Vec::new(),
            emotional_tone: EmotionalTone::Neutral,
            triggered_events: Vec::new(),
        }
    }

    /// Create a response with emotional tone.
    pub fn with_tone(text: impl Into<String>, tone: EmotionalTone) -> Self {
        Self {
            narrative_text: text.into(),
            suggested_actions: Vec::new(),
            emotional_tone: tone,
            triggered_events: Vec::new(),
        }
    }

    /// Add a triggered event to the response.
    pub fn with_triggered_event(mut self, event: GameEvent) -> Self {
        self.triggered_events.push(event);
        self
    }

    /// Add a suggested action.
    pub fn with_suggestion(mut self, action: impl Into<String>) -> Self {
        self.suggested_actions.push(action.into());
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_combat_event_tags() {
        let source = EntityId::new();
        let target = EntityId::new();

        let event = GameEvent::CombatAbilityUsed {
            source,
            target,
            ability: "Fireball".to_string(),
        };

        let tags = event.to_tags();

        assert!(tags.contains(&Tag::entity(source)));
        assert!(tags.contains(&Tag::entity(target)));
        assert!(tags.contains(&Tag::concept("Combat")));
        assert!(tags.contains(&Tag::concept("Fireball")));
    }

    #[test]
    fn test_involved_entities() {
        let a = EntityId::new();
        let b = EntityId::new();

        let event = GameEvent::RelationshipModified {
            entity_a: a,
            entity_b: b,
            old_sentiment: 0.0,
            new_sentiment: 0.5,
            reason: "Shared adventure".to_string(),
        };

        let entities = event.involved_entities();
        assert_eq!(entities.len(), 2);
        assert!(entities.contains(&a));
        assert!(entities.contains(&b));
    }

    #[test]
    fn test_dialogue_event() {
        let speaker = EntityId::new();
        let listener = EntityId::new();

        let event = GameEvent::DialogueStarted {
            participants: vec![speaker, listener],
            topic: Some("The Ancient Prophecy".to_string()),
        };

        let tags = event.to_tags();
        assert!(tags.contains(&Tag::concept("Dialogue")));
        assert!(tags.contains(&Tag::concept("The Ancient Prophecy")));
    }

    #[test]
    fn test_narrative_response_builder() {
        let response = NarrativeResponse::with_tone("The battle rages on!", EmotionalTone::Tense)
            .with_suggestion("Attack")
            .with_suggestion("Defend")
            .with_triggered_event(GameEvent::CombatStarted {
                participants: vec![],
                location: LocationId::new(),
            });

        assert_eq!(response.narrative_text, "The battle rages on!");
        assert_eq!(response.emotional_tone, EmotionalTone::Tense);
        assert_eq!(response.suggested_actions.len(), 2);
        assert_eq!(response.triggered_events.len(), 1);
    }

    #[test]
    fn test_event_type_names() {
        assert_eq!(
            GameEvent::CombatStarted {
                participants: vec![],
                location: LocationId::new()
            }
            .event_type_name(),
            "CombatStarted"
        );

        assert_eq!(
            GameEvent::EntityDied {
                entity: EntityId::new(),
                killer: None
            }
            .event_type_name(),
            "EntityDied"
        );
    }

    #[test]
    fn test_primary_entity() {
        let entity = EntityId::new();

        let event = GameEvent::LocationEntered {
            entity,
            location: LocationId::new(),
        };

        assert_eq!(event.primary_entity(), Some(entity));
    }

    #[test]
    fn test_custom_event() {
        let event = GameEvent::Custom {
            event_type: "CustomBossSpawn".to_string(),
            data: serde_json::json!({
                "boss_id": "ancient_dragon",
                "difficulty": 5
            }),
        };

        assert_eq!(event.event_type_name(), "Custom");
    }
}
